参考 
http://yulingtianxia.com/blog/2015/12/06/The-Principle-of-Refenrence-Counting/
https://juejin.im/post/5b4c59a55188251ac9767872#heading-5

来自objc4-723
### 1. NSObject, Class,id, objc_class, objc_object的关系
在Object.mm文件中
```
typedef struct objc_class *Class;
typedef struct objc_object *id;
```
Class的本质是objc_class结构体，id本质是objc_object，这段类型定义一定程度上说明了为什么在使用的时候id不用加星号，为什么id可以表示类型。
还有就是 isa 是 Class 类型的。

objc_class的定义, 它继承于objc_object（C++中的struct是可以继承的）
```
struct objc_class : objc_object { 
.......
    
}
```

### 2. retain 操作
类对象调用 retain直接返回self,不做其他操作。
```
+(id) retain
{
    return self;
}
```
实例对象，调用 retain，则会有以下调用
```
retain -> _objc_rootRetain(self) -> rootRetain() -> rootRetain(false, false)
```
也就是对象的retain操作，最终可以定位到`objc_object::rootRetain(bool tryRetain, bool handleOverflow)`这个方法中。

我们知道 retain有两个作用：1.对象引用计数加一， 2.返回对象本身。

#### 2.1 isa
rootRetain内的具体实现相对比较复杂，涉及到的量大关键结构是：isa和sideTable。需要弄懂retain，需要先了解这两个东西，先看下arm64下面的isa结构如下:

它是一个共用体。
```
union isa_t 
{
    isa_t() { }
    isa_t(uintptr_t value) : bits(value) { }

    Class cls; //实例对象，cls指向类对象；类对象cls指向元类对象。64位设备占用8字节
    uintptr_t bits;
    
    struct {
        uintptr_t nonpointer        : 1; //是否指针优化
        uintptr_t has_assoc         : 1; //是否设置了关联（objc_setAssociatedObject）
        uintptr_t has_cxx_dtor      : 1; //是否设置了析构函数，如果没有，释放对象更快
        uintptr_t shiftcls          : 33;// 存储class  meta-class对象内存地址
        uintptr_t magic             : 6; //在调试时分辨对象是否已经完成初始化
        uintptr_t weakly_referenced : 1; //是否被弱引用指向过（_weak声明）没有释放更快
        uintptr_t deallocating      : 1; //是否正在释放
        uintptr_t has_sidetable_rc  : 1; //当引用计数大于10，改值为1，然后引用计数存储在SideTable中
        uintptr_t extra_rc          : 19; //存储的值时对象引用计数值减1，比如对象引用计数为10，该值就为9（使用二进制表示）
#       define RC_ONE   (1ULL<<45)
#       define RC_HALF  (1ULL<<18)
    };
}
```
从isa内部结构体已经可以很明显地告诉我们`对象引用计数存在哪里`。

引用计数可以存储在两个地方，一个是isa结构体内的extra_rc，另一个是sideTable的属性里。

其中对于extra_rc执行了这一句让引用计数加1
```
newisa.bits = addc(newisa.bits, RC_ONE, 0, &carry);  // extra_rc++
```

**为什么extra_rc里存储的值是引用计数减一？** 这个涉及到 sideTable release操作，后面会提。

对于`sideTable`，主要涉及两个方法`sidetable_tryRetain()`，`sidetable_retain()`

#### 2.2 sideTable
在解释一堆概念之前，先简单了解一下sideTable结构。（这里删减一写相对不重要的东西）
这里只做简单介绍，后续再用其他篇幅去详细介绍。
```
struct SideTable {
    spinlock_t slock;
    RefcountMap refcnts;
    weak_table_t weak_table;

    void lock() { slock.lock(); }
    void unlock() { slock.unlock(); }
    void forceReset() { slock.forceReset(); }

    // Address-ordered lock discipline for a pair of side tables.
    static void lockTwo(SideTable *lock1, SideTable *lock2);
    static void unlockTwo(SideTable *lock1, SideTable *lock2);
};
```
其中 refcnts 就是存储了引用计数，是RefcountMap类型的散列表，而weak_table是弱引用表。

`sidetable_tryRetain()`的实现如下:

```
bool
objc_object::sidetable_tryRetain()
{

    SideTable& table = SideTables()[this];

    bool result = true;
    RefcountMap::iterator it = table.refcnts.find(this);
    if (it == table.refcnts.end()) {
        table.refcnts[this] = SIDE_TABLE_RC_ONE;
    } else if (it->second & SIDE_TABLE_DEALLOCATING) {
        result = false;
    } else if (! (it->second & SIDE_TABLE_RC_PINNED)) {
        it->second += SIDE_TABLE_RC_ONE;
    }
    
    return result;
}
```
获取对象的sideTable，通过一些操作，让它refcnts里面存储的引用计数加1,如果操作成功会返回true

```
id
objc_object::sidetable_retain()
{

    SideTable& table = SideTables()[this];
    
    table.lock();
    size_t& refcntStorage = table.refcnts[this];
    if (! (refcntStorage & SIDE_TABLE_RC_PINNED)) {
        refcntStorage += SIDE_TABLE_RC_ONE;
    }
    table.unlock();

    return (id)this;
}
```
sidetable_retain也是对refcnts里面存储的引用计数操作，只是它返回对象本身。为了保证线程安全，还加了自旋锁。


#### 2.3 extra_rc 引用计数溢出
在rootRetain里面有这么一段代码
```
newisa.bits = addc(newisa.bits, RC_ONE, 0, &carry);  // extra_rc++

if (slowpath(carry)) {
  // newisa.extra_rc++ overflowed
  if (!handleOverflow) {
      ClearExclusive(&isa.bits);
      return rootRetain_overflow(tryRetain);
  }
  // Leave half of the retain counts inline and 
  // prepare to copy the other half to the side table.
  if (!tryRetain && !sideTableLocked) sidetable_lock();
  sideTableLocked = true;
  transcribeToSideTable = true;
  newisa.extra_rc = RC_HALF;
  newisa.has_sidetable_rc = true;
}

if (slowpath(transcribeToSideTable)) {
   // Copy the other half of the retain counts to the side table.
   sidetable_addExtraRC_nolock(RC_HALF);
}

```
引用计数增加操作，优先增加isa的extra_rc,当溢出的时候，引用计数一半留在extra_rc，另一边拷贝到SideTable中，并把newisa.has_sidetable_rc设为true。 这点在很多博客中都没有说明



